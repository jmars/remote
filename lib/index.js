// Generated by IcedCoffeeScript 1.3.3e
var Future, Remote, uuid,
  __slice = [].slice;

uuid = require('uuid');

Future = require('future');

Remote = function(port, local, api) {
  var connected, k, queue, remote, waiting, _fn, _i, _len;
  waiting = {};
  remote = {};
  queue = [];
  connected = false;
  _fn = function() {
    var key;
    key = k;
    return remote[key] = function() {
      var args, future, message, uid;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      future = Future();
      uid = uuid.generate();
      waiting[uid] = future;
      message = JSON.stringify([uid, key, args]);
      if (connected) {
        port.send(message);
      } else {
        queue.push(message);
      }
      return future;
    };
  };
  for (_i = 0, _len = api.length; _i < _len; _i++) {
    k = api[_i];
    _fn();
  }
  port.open = function() {
    var message, _j, _len1;
    connected = true;
    for (_j = 0, _len1 = queue.length; _j < _len1; _j++) {
      message = queue[_j];
      port.send(message);
    }
    queue = [];
  };
  port.close = function() {
    connected = false;
  };
  local.prototype.Future = Future;
  port.recieve = function(message) {
    var args, future, key, results, uid, _ref;
    message = JSON.parse(message);
    switch (message.length) {
      case 2:
        uid = message[0], results = message[1];
        (_ref = waiting[uid]).resolve.apply(_ref, results);
        return delete waiting[uid];
      case 3:
        uid = message[0], key = message[1], args = message[2];
        future = local[key].apply(local, args);
        if (future.toString() !== '[Future]') {
          throw new TypeError('API functions must return a Future.');
        }
        return future(function() {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return port.send(JSON.stringify([uid, args]));
        });
    }
  };
  return remote;
};

module.exports = Remote;
