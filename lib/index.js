// Generated by IcedCoffeeScript 1.3.3e
var RPC, Stream, uuid,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __slice = [].slice;

uuid = require('uuid');

Stream = require('stream');

RPC = (function(_super) {

  __extends(RPC, _super);

  function RPC(local) {
    this.local = local;
    RPC.__super__.constructor.apply(this, arguments);
    this.readable = true;
    this.writable = true;
    this.waiting = {};
    this.remote = {};
    this.paused = false;
  }

  RPC.prototype.write = function(data) {
    var args, k, key, message, result, uid, _fn, _i, _len, _ref, _ref1,
      _this = this;
    message = JSON.parse(data);
    switch (message.type) {
      case 'keys':
        _ref = message.keys;
        _fn = function() {
          var key;
          key = k;
          return _this.remote[key] = function() {
            var args, cb, uid, _j;
            args = 2 <= arguments.length ? __slice.call(arguments, 0, _j = arguments.length - 1) : (_j = 0, []), cb = arguments[_j++];
            uid = uuid.generate();
            _this.waiting[uid] = cb;
            message = JSON.stringify({
              uid: uid,
              key: key,
              args: args,
              type: 'call'
            });
            return _this.emit('data', message);
          };
        };
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          k = _ref[_i];
          _fn();
        }
        return this.emit('remote', this.remote);
      case 'handshake':
        return this.emit('data', JSON.stringify({
          type: 'keys',
          keys: Object.keys(this.local)
        }));
      case 'return':
        uid = message.uid, result = message.result;
        (_ref1 = this.waiting)[uid].apply(_ref1, result);
        return delete this.waiting[uid];
      case 'call':
        uid = message.uid, key = message.key, args = message.args;
        return local[key].apply(local, [args].concat(function() {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return this.emit('data', JSON.stringify({
            uid: uid,
            result: args,
            type: 'return'
          }));
        }));
    }
  };

  RPC.prototype.pipe = function() {
    RPC.__super__.pipe.apply(this, arguments);
    return this.emit('data', JSON.stringify({
      type: 'handshake'
    }));
  };

  RPC.prototype.pause = function() {};

  RPC.prototype.resume = function() {};

  RPC.prototype.end = function(data) {};

  return RPC;

})(Stream);

module.exports = RPC;
